name: Build pg_uuidv7 Extension

on:
  push:
    paths:
      - 'pg_uuidv7/**'
  workflow_call:
    inputs:
      package-version:
        required: true
        type: string
      pg-version:
        required: false
        type: string
        default: "18"
      distro:
        required: false
        type: string
        default: "bookworm"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      
      - name: Get latest package version
        id: latest
        run: |
          LATEST=$(curl -fsS https://api.github.com/repos/${REPO}/tags | jq -r '.[0].name')
          echo "version=${LATEST}" >> $GITHUB_OUTPUT

      - name: Set package version to build
        id: version
        run: |
          PACKAGE_VER="${{ inputs.package-version || steps.latest.outputs.version }}"
          echo Using "version=$PACKAGE_VER"
          echo "version=${PACKAGE_VER}" >> $GITHUB_OUTPUT

      - name: Clone package source
        run: |
          git clone https://github.com/${REPO}.git pg_uuidv7/source
          cd pg_uuidv7/source
          git checkout ${{ steps.version.outputs.version }}
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push
        run: |
          cd pg_uuidv7
          PG_UUIDV7_VER="${{ steps.version.outputs.version }}"
          
          # Choose target and set variables based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # Build all combinations for main branch
            REGISTRY="ghcr.io/${{ github.repository_owner }}" \
            PG_UUIDV7_VERSION="${PG_UUIDV7_VER}" \
            docker buildx bake \
              --set "*.context=source" \
              --set "*.args.PG_UUIDV7_VERSION=${PG_UUIDV7_VER}" \
              pg_uuidv7-all \
              --push
          else
            # Build single combination for feature branch
            TARGET="pg_uuidv7-feature"
            REGISTRY="ghcr.io/${{ github.repository_owner }}" \
            PG_VERSION="${{ inputs.pg-version || '18' }}" \
            DISTRO="${{ inputs.distro || 'bookworm' }}" \
            PG_UUIDV7_VERSION="${PG_UUIDV7_VER}" \
            BRANCH_NAME="${{ github.ref_name }}" \
            docker buildx bake \
              --set pg_uuidv7-feature.context=source \
              --set "*.args.PG_VERSION=${{ inputs.pg-version || '18' }}" \
              --set "*.args.DISTRO=${{ inputs.distro || 'bookworm' }}" \
              --set "*.args.PG_UUIDV7_VERSION=${PG_UUIDV7_VER}" \
              ${TARGET} \
              --push
          fi
            
  smoke-test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      
      - name: Get latest package version
        id: latest
        run: |
          LATEST=$(curl -fsS https://api.github.com/repos/${REPO}/tags | jq -r '.[0].name')
          echo "version=${LATEST}" >> $GITHUB_OUTPUT

      - name: Set package version to build
        id: version
        run: |
          PACKAGE_VER="${{ inputs.package-version || steps.latest.outputs.version }}"
          echo Using "version=$PACKAGE_VER"
          echo "version=${PACKAGE_VER}" >> $GITHUB_OUTPUT
      
      - name: Setup Kind Cluster
        uses: helm/kind-action@v1
        with:
          version: v0.30.0
          kubectl_version: v1.34.0
          node_image: kindest/node:v1.34.0
          config: kind-config.yaml


      # - name: Check Kind Cluster Status
      #   run: |
      #     echo "Kind cluster 'kind' is ready."
      #     kubectl cluster-info
      #     kubectl get nodes
          
      - name: Install CloudNativePG Operator
        run: |
          # Get latest CNPG release
          CNPG_VERSION=$(curl -fsS https://api.github.com/repos/cloudnative-pg/cloudnative-pg/releases/latest | jq -r '.tag_name')
          echo "Installing CloudNativePG operator version: ${CNPG_VERSION}"
          
          # Extract version without 'v' prefix for branch name
          BRANCH_VERSION=$(echo ${CNPG_VERSION} | sed 's/^v//' | cut -d. -f1,2)
          
          # Install CNPG operator using correct URL format
          kubectl apply --server-side -f https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/release-${BRANCH_VERSION}/releases/cnpg-${CNPG_VERSION#v}.yaml
          
      - name: Verify CNPG Operator Installation
        run: |
          # Wait for operator deployment to be ready
          kubectl wait --for=condition=Available deployment/cnpg-controller-manager -n cnpg-system --timeout=120s
          
          # Check operator status
          kubectl get pods -n cnpg-system
          kubectl get deployment -n cnpg-system
          
          # Verify CRDs are installed
          kubectl get crd | grep postgresql
          
          echo "✅ CloudNativePG operator installed successfully"

      - name: Create Postgres Cluster with Extension
        run: |
          PG_VER="${{ inputs.pg-version || '18' }}"
          DISTRO="${{ inputs.distro || 'bookworm' }}"
          PG_UUIDV7_VER="${{ steps.version.outputs.version }}"
          
          # Set image tag based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            IMAGE_TAG="ghcr.io/${{ github.repository_owner }}/pg_uuidv7:${PG_VER}-${PG_UUIDV7_VER}-${DISTRO}"
          else
            IMAGE_TAG="ghcr.io/${{ github.repository_owner }}/pg_uuidv7:${PG_VER}-${PG_UUIDV7_VER}-${{ github.ref_name }}-${DISTRO}"
          fi
          
          echo "Testing with image: ${IMAGE_TAG}"
          
          # Create test pod with pg_uuidv7 extension
          kubectl apply -f - <<EOF
          apiVersion: postgresql.cnpg.io/v1
          kind: Cluster
          metadata:
            name: postgresql-with-extensions
            namespace: cnpg-system
          spec:
            instances: 1
            imageName: ghcr.io/cloudnative-pg/postgresql:${PG_VER}-${DISTRO}
            bootstrap:
              initdb:
                database: app
                postInitSQL:
                - CREATE EXTENSION pg_uuidv7
            postgresql:
              extensions:
                - name: pg-uuidv7
                  image:
                    reference: ${IMAGE_TAG}
            storage:
              storageClass: standard
              size: 1Gi
          EOF
          kubectl wait --for=jsonpath='{.status.phase}=Cluster in healthy state' cluster/postgresql-with-extensions --timeout=300s -n cnpg-system
          echo "✅ PostgreSQL cluster with pg_uuidv7 extension is ready"
          
      - name: Verify pg_uuidv7 Extension
        run: |
          EXTENSION_NAME="pg_uuidv7"
          NAMESPACE="cnpg-system"
          POD_NAME="postgresql-with-extensions-1"
          CONTAINER_NAME="postgres"
          
          echo "🔍 Checking if ${EXTENSION_NAME} extension is available..."
          
          # Wait a bit for the extension to be fully loaded
          sleep 10
          
          # Check if extension is available in pg_available_extensions
          if kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c \
             "psql -U postgres -d postgres -t -c \"SELECT name FROM pg_available_extensions WHERE name = '$EXTENSION_NAME';\"" | \
             grep -q "$EXTENSION_NAME"; then
              echo "✅ Success! The '$EXTENSION_NAME' extension is available."
          else
              echo "❌ Failure! The '$EXTENSION_NAME' extension was NOT found in pg_available_extensions."
          fi
          
      - name: Tag successful build
        if: success() && github.ref == 'refs/heads/main'
        run: |
          git tag "pg_uuidv7-${{ steps.version.outputs.version }}"
          git push origin "pg_uuidv7-${{ steps.version.outputs.version }}"
