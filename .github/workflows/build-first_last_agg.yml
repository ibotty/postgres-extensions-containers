name: Build first_last_agg Extension

on:
  push:
    paths:
      - 'first_last_agg/**'
  workflow_call:
    inputs:
      first_last_agg-version:
        required: true
        type: string
      pg-version:
        required: false
        type: string
        default: "18"
      distro:
        required: false
        type: string
        default: "bookworm"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Clone first_last_agg source
        if: github.event_name == 'workflow_call'
        run: |
          git clone https://github.com/wulczer/first_last_agg.git first_last_agg/source
          cd first_last_agg/source
          git checkout ${{ inputs.first_last_agg-version }}
          
      - name: Get latest first_last_agg version for push
        if: github.event_name == 'push'
        id: version
        run: |
          LATEST=$(curl -s https://api.github.com/repos/wulczer/first_last_agg/tags | jq -r '.[0].name')
          echo "version=${LATEST}" >> $GITHUB_OUTPUT
          git clone https://github.com/wulczer/first_last_agg.git first_last_agg/source
          cd first_last_agg/source
          git checkout ${LATEST}
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push
        run: |
          cd first_last_agg
          FIRST_LAST_AGG_VER="${{ inputs.first_last_agg-version || steps.version.outputs.version }}"
          
          # Choose target and set variables based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # Build all combinations for main branch
            REGISTRY="ghcr.io/${{ github.repository_owner }}" \
            FIRST_LAST_AGG_VERSION="${FIRST_LAST_AGG_VER}" \
            docker buildx bake \
              --set "*.context=source" \
              --set "*.args.FIRST_LAST_AGG_VERSION=${FIRST_LAST_AGG_VER}" \
              first_last_agg-all \
              --push
          else
            # Build single combination for feature branch
            TARGET="first_last_agg-feature"
            REGISTRY="ghcr.io/${{ github.repository_owner }}" \
            PG_VERSION="${{ inputs.pg-version || '18' }}" \
            DISTRO="${{ inputs.distro || 'bookworm' }}" \
            FIRST_LAST_AGG_VERSION="${FIRST_LAST_AGG_VER}" \
            BRANCH_NAME="${{ github.ref_name }}" \
            docker buildx bake \
              --set first_last_agg-feature.context=source \
              --set "*.args.PG_VERSION=${{ inputs.pg-version || '18' }}" \
              --set "*.args.DISTRO=${{ inputs.distro || 'bookworm' }}" \
              --set "*.args.FIRST_LAST_AGG_VERSION=${FIRST_LAST_AGG_VER}" \
              ${TARGET} \
              --push
          fi
            
  smoke-test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version from build
        id: get-version
        run: |
          if [ "${{ github.event_name }}" = "workflow_call" ]; then
            echo "version=${{ inputs.first_last_agg-version }}" >> $GITHUB_OUTPUT
          else
            LATEST=$(curl -s https://api.github.com/repos/wulczer/first_last_agg/tags | jq -r '.[0].name')
            echo "version=${LATEST}" >> $GITHUB_OUTPUT
          fi
      
      - name: Setup Kind Cluster
        uses: helm/kind-action@v1
        with:
          version: v0.30.0
          kubectl_version: v1.34.0
          node_image: kindest/node:v1.34.0
          config: kind-config.yaml


      # - name: Check Kind Cluster Status
      #   run: |
      #     echo "Kind cluster 'kind' is ready."
      #     kubectl cluster-info
      #     kubectl get nodes
          
      - name: Install CloudNativePG Operator
        run: |
          # Get latest CNPG release
          CNPG_VERSION=$(curl -s https://api.github.com/repos/cloudnative-pg/cloudnative-pg/releases/latest | jq -r '.tag_name')
          echo "Installing CloudNativePG operator version: ${CNPG_VERSION}"
          
          # Extract version without 'v' prefix for branch name
          BRANCH_VERSION=$(echo ${CNPG_VERSION} | sed 's/^v//' | cut -d. -f1,2)
          
          # Install CNPG operator using correct URL format
          kubectl apply --server-side -f https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/release-${BRANCH_VERSION}/releases/cnpg-${CNPG_VERSION#v}.yaml
          
      - name: Verify CNPG Operator Installation
        run: |
          # Wait for operator deployment to be ready
          kubectl wait --for=condition=Available deployment/cnpg-controller-manager -n cnpg-system --timeout=120s
          
          # Check operator status
          kubectl get pods -n cnpg-system
          kubectl get deployment -n cnpg-system
          
          # Verify CRDs are installed
          kubectl get crd | grep postgresql
          
          echo "✅ CloudNativePG operator installed successfully"

      - name: Create Postgres Cluster with Extension
        run: |
          PG_VER="${{ inputs.pg-version || '18' }}"
          DISTRO="${{ inputs.distro || 'bookworm' }}"
          FIRST_LAST_AGG_VER="${{ steps.get-version.outputs.version }}"
          
          # Set image tag based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            IMAGE_TAG="ghcr.io/${{ github.repository_owner }}/first_last_agg:${PG_VER}-${FIRST_LAST_AGG_VER}-${DISTRO}"
          else
            IMAGE_TAG="ghcr.io/${{ github.repository_owner }}/first_last_agg:${PG_VER}-${FIRST_LAST_AGG_VER}-${{ github.ref_name }}-${DISTRO}"
          fi
          
          echo "Testing with image: ${IMAGE_TAG}"
          
          # Create test pod with first_last_agg extension
          kubectl apply -f - <<EOF
          apiVersion: postgresql.cnpg.io/v1
          kind: Cluster
          metadata:
            name: postgresql-with-extensions
            namespace: cnpg-system
          spec:
            instances: 1
            imageName: ghcr.io/cloudnative-pg/postgresql:${PG_VER}-${DISTRO}
            bootstrap:
              initdb:
                database: app
                postInitSQL:
                - CREATE EXTENSION first_last_agg
            postgresql:
              extensions:
                - name: first-last-agg
                  image:
                    reference: ${IMAGE_TAG}
            storage:
              storageClass: standard
              size: 1Gi
          EOF
          kubectl wait --for=jsonpath='{.status.phase}=Cluster in healthy state' cluster/postgresql-with-extensions --timeout=300s -n cnpg-system
          echo "✅ PostgreSQL cluster with first_last_agg extension is ready"
          
      - name: Verify first_last_agg Extension
        run: |
          EXTENSION_NAME="first_last_agg"
          NAMESPACE="cnpg-system"
          POD_NAME="postgresql-with-extensions-1"
          CONTAINER_NAME="postgres"
          
          echo "🔍 Checking if ${EXTENSION_NAME} extension is available..."
          
          # Wait a bit for the extension to be fully loaded
          sleep 10
          
          # Check if extension is available in pg_available_extensions
          if kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c \
             "psql -U postgres -d postgres -t -c \"SELECT name FROM pg_available_extensions WHERE name = '$EXTENSION_NAME';\"" | \
             grep -q "$EXTENSION_NAME"; then
              echo "✅ Success! The '$EXTENSION_NAME' extension is available."
          else
              echo "❌ Failure! The '$EXTENSION_NAME' extension was NOT found in pg_available_extensions."
          fi
          
      - name: Tag successful build
        if: success() && github.ref == 'refs/heads/main'
        run: |
          git tag "first_last_agg-${{ steps.get-version.outputs.version }}"
          git push origin "first_last_agg-${{ steps.get-version.outputs.version }}"
